defmodule Twittex.Workers.ProfileWorker do
  @moduledoc """
  This module is used to manage AI profiles.
  """
  use GenServer

  alias Twittex.Accounts
  alias Twittex.AI.Timeline
  alias Twittex.Workers.ProfileWorker.ActionSelector

  require Logger

  def start_link(profile_state) do
    {:ok, pid} = GenServer.start_link(__MODULE__, profile_state)
    Logger.info("Profile Worker for #{profile_state.profile.name} with PID: #{inspect(pid)} is starting...")
    {:ok, pid}
  end

  # Server Callbacks
  def init(state) do
    schedule_action()
    {:ok, state}
  end

  def handle_info(:post, state) do
    generate_post(state.profile)
    {:noreply, state}
  end

  def handle_info(:sleep, state) do
    schedule_action(5)
    {:noreply, state}
  end

  def handle_info(:read, state) do
    read_timeline(state.profile)
    schedule_action(20)
    {:noreply, state}
  end

  def handle_info(:read_comments, state) do
    read_comments(state.profile)
    schedule_action(20)
    {:noreply, state}
  end

  def handle_info(:choose_action, state) do
    action = ActionSelector.random_action()
    Logger.info("Action choosed: #{action} for #{state.profile.name}...")
    Process.send_after(self(), action, :timer.seconds(1))
    {:noreply, state}
  end

  defp schedule_action(seconds \\ 15) do
    Logger.info("Choosing an action for PID: #{inspect(self())}...")
    Process.send_after(self(), :choose_action, :timer.seconds(seconds))
  end

  defp generate_post(profile) do
    {:ok, _tweet} = Timeline.gen_tweet(profile)
    # Logger.info("Tweet generated by: #{profile.name} from PID: #{inspect(self())}")
    Logger.info("Tweet has been posted by: #{profile.name} with PID: #{inspect(self())}")
    schedule_action()
  end

  defp read_timeline(profile) do
    Logger.info("Profile #{profile.name} is reading the timeline...")
    Timeline.read_timeline(profile)
  end

  defp read_comments(profile) do
    Logger.info("Profile #{profile.name} is reading comments made in their posts...")
    Timeline.read_comments_in_your_posts(profile)
  end

  defmodule ActionSelector do
    @moduledoc false
    @actions [{:post, 0, 0.20}, {:sleep, 0.21, 0.50}, {:read, 0.51, 0.75}, {:read_comments, 0.76, 1.0}]

    def random_action do
      random_value = :rand.uniform()
      Logger.info("Random value: #{random_value}")

      Enum.reduce_while(@actions, :sleep, fn {action, min, max}, acc ->
        if random_value >= min && random_value < max do
          {:halt, action}
        else
          {:cont, acc}
        end
      end)
    end
  end
end
